# 陣列和堆疊

前面講了線性和鏈式結構，如果你顺利掌握了，下邊的陣列和堆疊就小菜一碟了。因為我們會用前兩章講到的東西來實現陣列和堆疊。
之所以放到一起講是因為這兩個東西很類似，陣列是先進先出結構(FIFO, first in first out)，
堆疊是後進先出結構(LIFO, last in first out)。

生活中的數據結構：

- 陣列。没错就是咱平常排隊，第一個來的第一個走

本章我們详细講講常用的陣列

# 陣列 Queue

這裡卖個關子，如果你熟悉了上兩節講的内容，這裡你會選取哪個數據結構作為陣列的底层存儲？
還记得第一章講的如何實現 ADT 嗎？我影片了說了三個注意事項：

- 1.如何選用恰當的數據結構作為存儲？
- 2.選取的數據結構能否满足 ADT 的功能需求
- 3.實現效率如何？

我們先來看看 list 可以不？對照這個三個需求，看看能否满足：

- 1.我們選择了 list
- 2.看起來陣列需要從頭删除，向尾部增加元素，也就是 list.insert(0, element) 和 list.append(element)
- 3.嗯，貌似 list.insert(0, element) 會导致所有list元素後移，O(n)複雜度。append 平均倒是O(1)，但是如果記憶體不够還要重新分配記憶體。

你看，使用了 list 的話頻繁 insert(0, element) 和 append 都是非常低效的。

腦子再轉轉， 我們第二章實現了 鏈表 LinkedList，看看能否满足要求：
- 1.這裡選择 LinkedList
- 2.删除頭元素 LinkedList.popleft()，追加 append(element)。都可以满足
- 3.哇欧，這兩個操作都是 O(1) 的，完美。

好， 就用 LinkedList 了，我們開始實現，具體看影片。這次實現我們還將演示自定義异常和測試异常。


# 用數組實現陣列

难道用數組就不能實現陣列了嗎？其實還是可以的。只不過數組是預先分配固定記憶體的，所以如果你知道了陣列的最大長度，也是
可以用數組來實現的。

想象一下，陣列就俩操作，進進出出，一進一出，pop 和 push 操作。
似乎只要兩個下標 head, tail 就可以了。 當我們 push 的時候赋值並且前移 head，pop 的時候前移 tail 就可以了。你可以在纸上
模擬下試試。列隊的長度就是 head-pop，這個長度必须不能大於初始化的最大程度。

如果 head 先到了數組末尾咋办？重頭來呗，只要我們保證 tail 不會超過 head 就行。

head = 0,1,2,3,4 ... 0,1,2,3,4 ...

重頭再來，循環往复，仿佛一個輪回。。。。
怎麼重頭來呢？看上邊數組的规律你如果還想不起來用取模，估計小學數學是體育老师教的。

```py
maxsize = 5
for i in range(100):
    print(i % maxsize)
```

![](./array_queue.png)

我們來實現一個空間有限的循環陣列。ArrayQueue，它的實現很簡單，但是缺點是需要預先知道陣列的長度來分配記憶體。


# 双端陣列 Double ended Queue
看了影片相信你已經會實現陣列了，你可能還聽過双端陣列。上邊講到的陣列 隊頭出，尾尾進，我們如果想頭部和尾巴都能進能出呢？
這就是双端陣列了，如果你用過 collections.deque 模塊，就是這個東西。他能高效在兩頭操作。

假如讓你實現你能想起來嘛？
似乎我們需要一個能 append()  appendleft() popleft() pop() 都是 O(1) 的數據結構。

上邊我們實現 陣列的 LinkedList 可以嗎？貌似就差一個 pop() 最後面的元素無法實現了。
對，我們還有双端鏈表。它有這幾個方法：

- append
- appendleft
- headnode()
- tailnode()
- remove(node)    # O(1)

啊哈，似乎删除頭尾都可以啦，而且都是 O(1) 的，完美。
交给你一個艰巨的任务，實現双端陣列 Deque（） ADT。你可以参考前幾章的任何原始碼，挑战一下這個任务，别忘记寫單元測試呦。當然如果没想出來也没關系，後面我們實現堆疊的時候還會用到它，那裡我們會實現這個原始碼。


# 思考题
- 你能用 python 的 deque 來實現 queue ADT 嗎？
- 哪些經典算法裡用到了陣列呢？
