# 队列和栈

前面講了線性和鏈式結構，如果你顺利掌握了，下邊的队列和栈就小菜一碟了。因為我們會用前兩章講到的東西來實現队列和栈。
之所以放到一起講是因為這兩個東西很类似，队列是先进先出結構(FIFO, first in first out)，
栈是後进先出結構(LIFO, last in first out)。

生活中的數據結構：

- 队列。没错就是咱平常排队，第一個來的第一個走

本章我們详细講講常用的队列

# 队列 Queue

這裡卖個關子，如果你熟悉了上兩節講的内容，這裡你會選取哪個數據結構作為队列的底层存儲？
還记得第一章講的如何實現 ADT 嗎？我影片了說了三個注意事項：

- 1.如何選用恰當的數據結構作為存儲？
- 2.選取的數據結構能否满足 ADT 的功能需求
- 3.實現效率如何？

我們先來看看 list 可以不？對照這個三個需求，看看能否满足：

- 1.我們選择了 list
- 2.看起來队列需要從头删除，向尾部增加元素，也就是 list.insert(0, element) 和 list.append(element)
- 3.嗯，貌似 list.insert(0, element) 會导致所有list元素後移，O(n)複雜度。append 平均倒是O(1)，但是如果内存不够還要重新分配内存。

你看，使用了 list 的话频繁 insert(0, element) 和 append 都是非常低效的。

脑子再转转， 我們第二章實現了 鏈表 LinkedList，看看能否满足要求：
- 1.這裡選择 LinkedList
- 2.删除头元素 LinkedList.popleft()，追加 append(element)。都可以满足
- 3.哇欧，這兩個操作都是 O(1) 的，完美。

好， 就用 LinkedList 了，我們開始實現，具體看影片。這次實現我們還将演示自定義异常和測试异常。


# 用数組實現队列

难道用数組就不能實現队列了嗎？其實還是可以的。只不過数組是预先分配固定内存的，所以如果你知道了队列的最大长度，也是
可以用数組來實現的。

想象一下，队列就俩操作，进进出出，一进一出，pop 和 push 操作。
似乎只要兩個下標 head, tail 就可以了。 當我們 push 的时候赋值并且前移 head，pop 的时候前移 tail 就可以了。你可以在纸上
模擬下试试。列队的长度就是 head-pop，這個长度必须不能大于初始化的最大程度。

如果 head 先到了数組末尾咋办？重头來呗，只要我們保证 tail 不會超過 head 就行。

head = 0,1,2,3,4 ... 0,1,2,3,4 ...

重头再來，循環往复，仿佛一個轮回。。。。
怎麼重头來呢？看上邊数組的规律你如果還想不起來用取模，估计小學数學是體育老师教的。

```py
maxsize = 5
for i in range(100):
    print(i % maxsize)
```

![](./array_queue.png)

我們來實現一個空間有限的循環队列。ArrayQueue，它的實現很簡單，但是缺點是需要预先知道队列的长度來分配内存。


# 双端队列 Double ended Queue
看了影片相信你已經會實現队列了，你可能還听過双端队列。上邊講到的队列 队头出，尾尾进，我們如果想头部和尾巴都能进能出呢？
這就是双端队列了，如果你用過 collections.deque 模塊，就是這個東西。他能高效在兩头操作。

假如让你實現你能想起來嘛？
似乎我們需要一個能 append()  appendleft() popleft() pop() 都是 O(1) 的數據結構。

上邊我們實現 队列的 LinkedList 可以嗎？貌似就差一個 pop() 最後面的元素无法實現了。
對，我們還有双端鏈表。它有這几個方法：

- append
- appendleft
- headnode()
- tailnode()
- remove(node)    # O(1)

啊哈，似乎删除头尾都可以啦，而且都是 O(1) 的，完美。
交给你一個艰巨的任务，實現双端队列 Deque（） ADT。你可以参考前几章的任何代碼，挑战一下這個任务，别忘记写單元測试呦。當然如果没想出來也没關系，後面我們實現栈的时候還會用到它，那里我們會實現這個代碼。


# 思考题
- 你能用 python 的 deque 來實現 queue ADT 嗎？
- 哪些經典算法里用到了队列呢？
