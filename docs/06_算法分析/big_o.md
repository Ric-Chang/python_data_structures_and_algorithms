# 算法複雜度分析
前面我們說了很多次時間複雜度是 O(1), O(n) 啥的，并没有仔细講解這個 O 符號究竟是什麼。
你可以大概理解為操作的次数和數據個数的比例關系。比如 O(1) 就是有限次数操作，O(n) 就是操作正比于你的元素個数。
這一章我們用更严谨的方式來定義它。


# 大 O 表示法
我們從一個計算矩阵的例子來引入，這裡我参考了 [《Data Structures and Algorithms in Python》](
https://book.douban.com/subject/10607365/) 中给的一個例子:

考虑計算一個 n * n 矩阵所有元素的和（如果你不知道矩阵，就理解為一個二维数組）：

$$
        \begin{bmatrix}
        0 & 1 & 2 \\
        3 & 4 & 5 \\
        6 & 7 & 8 \\
        \end{bmatrix}
$$

這裡列舉兩種方式:

```py
# version1
total_sum = 0
for i in range(n):
    row_sum[i] = 0
    for j in range(n):
        row_sum[i] = row_sum[i] + matrix[i, j]
        total_sum = total_sum + matrix[i, j]

# version2
total_sum = 0
for i in range(n):
    row_sum[i] = 0
    for j in range(n):
        row_sum[i] = row_sum[i] + matrix[i, j]
    total_sum = total_sum + row_sum[i]    # 注意這裡和上邊的不同
```

v1 版本的關键操作在 j 循環里，兩步加法操作，由于嵌套在第一個循環里，操作步骤是 $  (2n) * n = 2n^2  $。

v2 版本的 total_sum 只有 n 次操作，它的操作次数是 $ n + n*n = n^2 + n $。


這裡你可能還感覺不到它們有多大差别，因為計算機执行的太快了，但是當 n 增長特别快的時候，总的操作次数差距就很明显了：

n      | $ 2n^2 $       | $ n^2 +n $     |
-------|----------------|----------------|
10     | 200            | 110            |
100    | 20,000         | 10,100         |
1000   | 2,000,000      | 1,001,000      |
10000  | 200,000,000    | 100,010,000    |
100000 | 20,000,000,000 | 10,000,100,000 |

通常我們不太關注每個算法具體执行了多少次，而更關心随着输入規模 n 的增加，算法運行時間將以什麼速度增加。為此計算機科學家定義了一個符號，
用來表示在最糟糕的情况下算法的運行時間，大 O 符號，在数學上称之為渐进上界（《算法导论》）。

# 如何計算時間複雜度
上邊我們列舉了兩個版本的計算矩阵和的代碼，你看到了兩個公式:

- v1: $ 2n*n = 2n^2 $
- v2: $ n + n*n = n + n^2 $

當 n 非常大的時候，$ n^2 $ 的数值這裡將占主导，我們可以忽略 n 的影响

- v1: $ 2n*n = 2n^2 $
- v2: $ n + n*n = n + n^2 \leq 2n^2 $

這裡我們可以认為兩個算法的時間複雜度均為 $ O(n^2) $

# 常用時間複雜度
這裡我們列舉一些常用的時間複雜度，按照增長速度排序，日常我們的業務代碼中最常用的是指数之前的複雜度，指数和階乘的增長速度非常快，
當输入比较大的時候用在業務代碼里是不可接受的。

O         | 名称         | 舉例               |
----------|--------------|--------------------|
1         | 常量時間     | 一次赋值           |
$\log n$  | 對数時間     | 折半查找           |
$n$       | 線性時間     | 線性查找           |
n$\log n$ | 對数線性時間 | 快速排序           |
$n^2$     | 平方         | 兩重循環           |
$n^3$     | 立方         | 三重循環           |
$2^n$     | 指数         | 遞迴求斐波那契数列 |
$n!$      | 階乘         | 旅行商問題         |


# 空間複雜度
相比時間複雜度，空間複雜度討論比较少。因為用户老爷等不及，况且现在存儲越來越白菜價了，更多時候我們為了提升响应速度宁可多 使用點空間。
空間複雜度相對好算一些，就是每個元素的空間占用乘以总的元素数，有些算法需要额外的空間存儲，有些可以本地解决。
如果能本地搞定的我們成為 in place 的，原地操作，比如交换一個 数組中的某兩個位置的元素。但是有些操作可能就需要申請额外的空間
來完成算法了，後面我們介绍排序算法的時候會講到。


# 常見複雜度增長趨势图
為了让你有個直觀的感覺，我們來看看一些經典的時間複雜度和對应的增長趨势图，不同函数在输入規模增長的時候很快就會有巨大的增長差异

![函数增長趨势图](./function_growth.png)


# 時間换空間，空間换時間
有一些時候時間和空間兩者不可兼得，我們會犧牲其中之一來换取另一個。

空間换時間：比如典型的就是 python 中的集合（後面會講到它的實現原理），雖然它比较浪费空間，但是却能用 O(1)
的時間複雜度來判重。

時間换空間：當我們空間不够用，典型的就是缓存失效算法，我們不可能缓存下无限容量的數據，就會使用一些缓存淘汰算法來保证空間可用。


# 思考题
- 回头看看前几章我們講到的數據結構，以及每個操作的時間複雜度，你能理解了嗎？
- 二分查找是針對有序元素的一種經典的查找算法，你知道的它的時間複雜度嗎？你能簡單证明下嗎。
- 斐波那契数列你肯定很熟悉，它的公式是 F(n) = F(n-1) + F(n-2)，你知道計算一個斐波那契数 F(n)
  的時間複雜度嗎？你會用数學公式证明嗎？
- 你能指出時間和空間权衡的例子嗎？往往很多高效的數據結構能同时兼顾時間和空間複雜度，但是有時候我們却得做出一定的权衡


# 参考資料
如果你對数學感興趣，建議你閱讀《算法导论》『函数的增長』這一節 和《Data Structures and Algorithms in Python》第4章。


(本章我用了 [MathJax](https://www.zybuluo.com/codeep/note/163962) 來书写一些簡單的数學公式，使用 "$"包含起來的就是数學公式)
