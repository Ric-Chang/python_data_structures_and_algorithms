# 基本排序算法
从本章開始講常見的基于比较的排序算法，先講三個簡單的但是時間複雜度却不太理想的排序算法，包括冒泡排序、选择排序和插入排序。


# 冒泡排序
bubble sort 可以說是最簡單的一種排序算法了，它的思想如下。對一個数组进行 n-1 轮迭代，每次比较相邻兩個元素，
如果相邻的元素前者大于後者，就交换它们。因為直接在元素上操作而不是返回新的数组，所以是一個 inplace 的操作。
這裡冒泡的意思其实就是每一轮冒泡一個最大的元素就會通過不断比较和交换相邻元素使它转移到最右邊。

你可以想象假如有 10 個小盆友从左到右站成一排，個头不等。老师想让他们按照個头从低到高站好，于是他開始喊口号。
每喊一次，从第一個小盆友開始，相邻的小朋友如果身高不是正序就會兩兩调换，就這样第一轮個头最高的排到了最右邊。(冒泡到最右邊)
第二轮依次這么來，从第一個小朋友開始兩兩交换，這样次高的小盆友又排到了倒数第二個位置。依次类推。


我們在影片里手動模擬下它的過程。


```py
import random


def bubble_sort(seq):  # O(n^2), n(n-1)/2 = 1/2(n^2 + n)
    n = len(seq)
    for i in range(n-1):
        print(seq)    # 我打印出來让你看清楚每一轮最高、次高、次次高...的小朋友會冒泡到右邊
        for j in range(n-1-i):  # 這裡之所以 n-1 還需要 减去 i 是因為每一轮冒泡最大的元素都會冒泡到最後，无需再比较
            if seq[j] > seq[j+1]:
                seq[j], seq[j+1] = seq[j+1], seq[j]
	print(seq)


def test_bubble_sort():
    seq = list(range(10))  # 注意 python3 返回迭代器，所以我都用 list 强转了，python2 range 返回的就是 list
    random.shuffle(seq)   # shuffle inplace 操作，打乱数组
    bubble_sort(seq)
    assert seq == sorted(seq)  # 注意呦，内置的 sorted 就不是 inplace 的，它返回一個新的数组，不影响传入的参数

""" 我打印出來让你看到每次从最高到次高的小盆友就這么排好序了，因為是随机数，你第一個没有排序的数组应该和我的不一样
[3, 4, 5, 0, 9, 1, 7, 8, 6, 2]
[3, 4, 0, 5, 1, 7, 8, 6, 2, 9]
[3, 0, 4, 1, 5, 7, 6, 2, 8, 9]
[0, 3, 1, 4, 5, 6, 2, 7, 8, 9]
[0, 1, 3, 4, 5, 2, 6, 7, 8, 9]
[0, 1, 3, 4, 2, 5, 6, 7, 8, 9]
[0, 1, 3, 2, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
"""
```



# 选择排序
刚才看到冒泡是每轮迭代中，如果相邻的兩個元素前者大于後者了就交换兩個相邻元素(假设正序排序)。其实還有一種思路就是，
每次我們找到最小的元素插入迭代的起始位置，這样每個位置从它自己的位置開始它就是最小的了，一圈下來数组就有序了。
选择可以理解為 一個 0 到 n-1 的迭代，每次向後查找选择一個最小的元素。

同样小盆友又來啦，這次我們从第一個開始，从头到尾找一個個头最小的小盆友，然後把它和第一個小盆友交换。
然後从第二個小盆友開始采取同样的策略，這样一圈下來小盆友就有序了。

```py
def select_sort(seq):
    n = len(seq)
    for i in range(n-1):
        min_idx = i    # 我們假设當前下标的元素是最小的
        for j in range(i+1, n):    # 从 i 的後面開始找到最小的元素，得到它的下标
            if seq[j] < seq[min_idx]:
                min_idx = j    # 一個 j 循環下來之後就找到了最小的元素它的下标
        if min_idx != i:    # swap
            seq[i], seq[min_idx] = seq[min_idx], seq[i]


def test_select_sort():
    seq = list(range(10))
    random.shuffle(seq)
    select_sort(seq)
    assert seq == sorted(seq)

"""
[4, 7, 5, 3, 6, 0, 2, 9, 8, 1]
[0, 7, 5, 3, 6, 4, 2, 9, 8, 1]
[0, 1, 5, 3, 6, 4, 2, 9, 8, 7]
[0, 1, 2, 3, 6, 4, 5, 9, 8, 7]
[0, 1, 2, 3, 6, 4, 5, 9, 8, 7]
[0, 1, 2, 3, 4, 6, 5, 9, 8, 7]
[0, 1, 2, 3, 4, 5, 6, 9, 8, 7]
[0, 1, 2, 3, 4, 5, 6, 9, 8, 7]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

"""
```


# 插入排序
插入排序很多教科书都是用扑克牌的例子講的，想象你手里有一些扑克牌，它们顺序是散乱的，现在需要你把它们整理成有序的，你會怎么做呢？
首先拿最顶上的一张，然後拿第二张，第二张點数大，你就把第二张放在第一张的下邊，否则放在第一张上邊。
當你拿第三张的时候，你同样會找到适合它大小的位置插入进去。

换成小朋友一样，第一個小盆友只有一個人我們假设是有序的，然後第二個小盆友會跟第一個比，如果第一個高就交换位置。
接下來第三個小盆友从第二個位置開始比较，如果没第二個高就交换位置，然後没第一個高也交换位置，保持前邊三個小盆友身高有序就好。
依次类推，等到最後一個小盆友也转移到合适的位置，整個队列就是有序的了。

插入排序就是這個道理, 每次挑选下一個元素插入已經排序的数组中,初始时已排序数组只有一個元素。我們就直接上代碼吧。


```py
def insertion_sort(seq):
    """ 每次挑选下一個元素插入已經排序的数组中,初始时已排序数组只有一個元素"""
    n = len(seq)
    print(seq)
    for i in range(1, n):
        value = seq[i]    # 保存當前位置的值，因為转移的過程中它的位置可能被覆盖
        # 找到這個值的合适位置，使得前邊的数组有序 [0,i] 有序
        pos = i
        while pos > 0 and value < seq[pos-1]:
            seq[pos] = seq[pos-1]  # 如果前邊的元素比它大，就让它一直前移
            pos -= 1
        seq[pos] = value    # 找到了合适的位置赋值就好
        print(seq)


""" 不断把新元素放到已經有序的数组中
[1, 7, 3, 0, 9, 4, 8, 2, 6, 5]
[1, 7, 3, 0, 9, 4, 8, 2, 6, 5]
[1, 3, 7, 0, 9, 4, 8, 2, 6, 5]
[0, 1, 3, 7, 9, 4, 8, 2, 6, 5]
[0, 1, 3, 7, 9, 4, 8, 2, 6, 5]
[0, 1, 3, 4, 7, 9, 8, 2, 6, 5]
[0, 1, 3, 4, 7, 8, 9, 2, 6, 5]
[0, 1, 2, 3, 4, 7, 8, 9, 6, 5]
[0, 1, 2, 3, 4, 6, 7, 8, 9, 5]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
"""
```


# 思考题
- 本章介绍的几個排序算法平均時間複雜度是多少？
- 請你补充插入排序的單元測试代碼


# 延伸閱讀
- 《Data Structures and Algorithms in Python》第5章
