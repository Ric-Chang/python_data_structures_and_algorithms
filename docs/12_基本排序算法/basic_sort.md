# 基本排序算法
從本章開始講常見的基於比较的排序算法，先講三個簡單的但是時間複雜度却不太理想的排序算法，包括冒泡排序、選择排序和插入排序。


# 冒泡排序
bubble sort 可以說是最簡單的一種排序算法了，它的思想如下。對一個數組進行 n-1 輪迭代，每次比较相邻兩個元素，
如果相邻的元素前者大於後者，就交換它們。因為直接在元素上操作而不是返回新的數組，所以是一個 inplace 的操作。
這裡冒泡的意思其實就是每一輪冒泡一個最大的元素就會通過不断比较和交換相邻元素使它轉移到最右邊。

你可以想象假如有 10 個小盆友從左到右站成一排，個頭不等。老师想讓他們按照個頭從低到高站好，於是他開始喊口号。
每喊一次，從第一個小盆友開始，相邻的小朋友如果身高不是正序就會兩兩調換，就這樣第一輪個頭最高的排到了最右邊。(冒泡到最右邊)
第二輪依次這麼來，從第一個小朋友開始兩兩交換，這樣次高的小盆友又排到了倒數第二個位置。依次類推。


我們在影片裡手動模擬下它的過程。


```py
import random


def bubble_sort(seq):  # O(n^2), n(n-1)/2 = 1/2(n^2 + n)
    n = len(seq)
    for i in range(n-1):
        print(seq)    # 我打印出來讓你看清楚每一輪最高、次高、次次高...的小朋友會冒泡到右邊
        for j in range(n-1-i):  # 這裡之所以 n-1 還需要 减去 i 是因為每一輪冒泡最大的元素都會冒泡到最後，無需再比较
            if seq[j] > seq[j+1]:
                seq[j], seq[j+1] = seq[j+1], seq[j]
	print(seq)


def test_bubble_sort():
    seq = list(range(10))  # 注意 python3 返回迭代器，所以我都用 list 强轉了，python2 range 返回的就是 list
    random.shuffle(seq)   # shuffle inplace 操作，打乱數組
    bubble_sort(seq)
    assert seq == sorted(seq)  # 注意呦，内置的 sorted 就不是 inplace 的，它返回一個新的數組，不影響傳入的参數

""" 我打印出來讓你看到每次從最高到次高的小盆友就這麼排好序了，因為是随機數，你第一個没有排序的數組應該和我的不一樣
[3, 4, 5, 0, 9, 1, 7, 8, 6, 2]
[3, 4, 0, 5, 1, 7, 8, 6, 2, 9]
[3, 0, 4, 1, 5, 7, 6, 2, 8, 9]
[0, 3, 1, 4, 5, 6, 2, 7, 8, 9]
[0, 1, 3, 4, 5, 2, 6, 7, 8, 9]
[0, 1, 3, 4, 2, 5, 6, 7, 8, 9]
[0, 1, 3, 2, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
"""
```



# 選择排序
刚才看到冒泡是每輪迭代中，如果相邻的兩個元素前者大於後者了就交換兩個相邻元素(假设正序排序)。其實還有一種思路就是，
每次我們找到最小的元素插入迭代的起始位置，這樣每個位置從它自己的位置開始它就是最小的了，一圈下來數組就有序了。
選择可以理解為 一個 0 到 n-1 的迭代，每次向後查找選择一個最小的元素。

同樣小盆友又來啦，這次我們從第一個開始，從頭到尾找一個個頭最小的小盆友，然後把它和第一個小盆友交換。
然後從第二個小盆友開始採取同樣的策略，這樣一圈下來小盆友就有序了。

```py
def select_sort(seq):
    n = len(seq)
    for i in range(n-1):
        min_idx = i    # 我們假设當前下標的元素是最小的
        for j in range(i+1, n):    # 從 i 的後面開始找到最小的元素，得到它的下標
            if seq[j] < seq[min_idx]:
                min_idx = j    # 一個 j 循環下來之後就找到了最小的元素它的下標
        if min_idx != i:    # swap
            seq[i], seq[min_idx] = seq[min_idx], seq[i]


def test_select_sort():
    seq = list(range(10))
    random.shuffle(seq)
    select_sort(seq)
    assert seq == sorted(seq)

"""
[4, 7, 5, 3, 6, 0, 2, 9, 8, 1]
[0, 7, 5, 3, 6, 4, 2, 9, 8, 1]
[0, 1, 5, 3, 6, 4, 2, 9, 8, 7]
[0, 1, 2, 3, 6, 4, 5, 9, 8, 7]
[0, 1, 2, 3, 6, 4, 5, 9, 8, 7]
[0, 1, 2, 3, 4, 6, 5, 9, 8, 7]
[0, 1, 2, 3, 4, 5, 6, 9, 8, 7]
[0, 1, 2, 3, 4, 5, 6, 9, 8, 7]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

"""
```


# 插入排序
插入排序很多教科书都是用扑克牌的例子講的，想象你手裡有一些扑克牌，它們顺序是散乱的，現在需要你把它們整理成有序的，你會怎麼做呢？
首先拿最顶上的一张，然後拿第二张，第二张點數大，你就把第二张放在第一张的下邊，否则放在第一张上邊。
當你拿第三张的時候，你同樣會找到适合它大小的位置插入進去。

換成小朋友一樣，第一個小盆友只有一個人我們假设是有序的，然後第二個小盆友會跟第一個比，如果第一個高就交換位置。
接下來第三個小盆友從第二個位置開始比较，如果没第二個高就交換位置，然後没第一個高也交換位置，保持前邊三個小盆友身高有序就好。
依次類推，等到最後一個小盆友也轉移到合适的位置，整個陣列就是有序的了。

插入排序就是這個道理, 每次挑選下一個元素插入已經排序的數組中,初始時已排序數組只有一個元素。我們就直接上原始碼吧。


```py
def insertion_sort(seq):
    """ 每次挑選下一個元素插入已經排序的數組中,初始時已排序數組只有一個元素"""
    n = len(seq)
    print(seq)
    for i in range(1, n):
        value = seq[i]    # 保存當前位置的值，因為轉移的過程中它的位置可能被覆盖
        # 找到這個值的合适位置，使得前邊的數組有序 [0,i] 有序
        pos = i
        while pos > 0 and value < seq[pos-1]:
            seq[pos] = seq[pos-1]  # 如果前邊的元素比它大，就讓它一直前移
            pos -= 1
        seq[pos] = value    # 找到了合适的位置赋值就好
        print(seq)


""" 不断把新元素放到已經有序的數組中
[1, 7, 3, 0, 9, 4, 8, 2, 6, 5]
[1, 7, 3, 0, 9, 4, 8, 2, 6, 5]
[1, 3, 7, 0, 9, 4, 8, 2, 6, 5]
[0, 1, 3, 7, 9, 4, 8, 2, 6, 5]
[0, 1, 3, 7, 9, 4, 8, 2, 6, 5]
[0, 1, 3, 4, 7, 9, 8, 2, 6, 5]
[0, 1, 3, 4, 7, 8, 9, 2, 6, 5]
[0, 1, 2, 3, 4, 7, 8, 9, 6, 5]
[0, 1, 2, 3, 4, 6, 7, 8, 9, 5]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
"""
```


# 思考题
- 本章介绍的幾個排序算法平均時間複雜度是多少？
- 請你补充插入排序的單元測試原始碼


# 延伸閱讀
- 《Data Structures and Algorithms in Python》第5章
