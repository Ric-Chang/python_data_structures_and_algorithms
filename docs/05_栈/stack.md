# 堆疊

堆疊這個詞實際上在計算機科學裡使用很多，除了數據結構外，還有記憶體裡的堆疊區 （和堆對應），熟悉 C 系语言的話應該不會陌生。
上一章我們講到了先進先出 queue，其實用 python 的内置類型 collections.deque 或者我們自己實現的 LinkedList 來實現它都很簡單。
本章我們講講 後進先出的堆疊。

生活中的數據結構：

- 堆疊。好比在桶裡頭放盘子，先放的盘子放在了底下，後來的盘子放在上邊。你要拿的時候，也是先拿最上邊的。

堆疊其實也很簡單，因為基础操作就俩，一個 push 和一個 pop，咦，咋和陣列一樣的？
確實方法名字一樣，但是得到的結果可是不同的。


# 堆疊 ADT

上一章我介绍了我們怎樣選取恰到的數據結構來實現新的 ADT？你能想到這裡我們應該使用之前提到的哪個數據結構來實現嗎？
你的大腦可能開始高(gui)速(su)旋轉了，上幾章學過的 array, list, deque, LinkedList, CircularDoubleLinkedList, queue
等在大腦裡呼啸而過，這個時候可能已經一臉愁容了，到底該選啥？

還用問嘛，當然是時間複雜度最小的啦，大部分情况下空間都是够用的。
其實你會發現堆疊比陣列還簡單，因為它只在頂上操作（想像装着盘子的桶），如果有一種數據結構能方便在尾部增减元素不就满足需求了嗎。
這個時候如果你忘記了，可以翻翻前幾章，看看哪個數據結構符合要求。

想一下，似乎 CircularDoubleLinkedList 循環双端陣列是满足的，因為增删最後一個元素都是 O(1)。
不過看了下示例原始碼，似乎没有 pop() 方法，對，因為我已經把實現 deque 作為思考题了。😂
如果之前你没寫出來也没關係，這裡我們會再實現它。


影片裡我們將借助 CircularDoubleLinkedList 實現 双端陣列 Deque ，並且用 Deque 實現 Stack。


# Stack over flow 什麼鬼？
嗯，stackoverflow 不是一個程序员問答網站嗎？没錯。
函數的临時变量是儲存在堆疊區的，如果你不幸寫了一個没有出口的遞迴函數，就會這個錯。不信你試試：


```py
def infinite_fib(n):
    return infinite_fib(n-1) + infinite_fib(n-2)
infinite_fib(10)
```

一大段輸出之後就會出現异常： RecursionError: maximum recursion depth exceeded。
後邊會講到遞迴，遞迴是初學者比较難理解的概念，在树的遍历等地方還會看到它。


# 數據結構頭腦風暴法

當我們不知道使用什麼數據結構來解決問题的時候，《程序员面試金典》這本书的第六章提到了一種方式叫做『數據結構頭腦風暴法』。
這種笨方法就是快速過一遍數據結構的列表，然後逐一嘗試各種數據結構看看哪個最適合。

在你實現一個更高级的數據結構的時候，如果腦子没有思路，不妨嘗試下這個方法，迅速過一遍你所知道的數據結構，看看哪種最適合。(從每個操作的時間複雜度和空間複雜度分析尋找最優解)

# 思考题
- 上一章我們用數組實現了陣列，其實也能用數組來實現堆疊，你能自己用數組來實現一個堆疊的 ADT 嗎？
- 實際上借助 python 内置的 list/collections.deque 結構就很容易實現一個堆疊，請你嘗試實現，本章我們全部使用自己编寫的數據結構而没用到 python 内置的數據結構。
- 這裡我們自己實現了 Deque，你能用 python 内置的 collections.deque 實現堆疊嗎？有輪子能直接用的話看起來就簡單多了，這裡我們為了學習數據結構的實現就避免了直接使用内置結構
- 哪些經典算法裡使用到了堆疊呢？

# Leetcode 練習

https://leetcode.com/problems/implement-queue-using-stacks/
